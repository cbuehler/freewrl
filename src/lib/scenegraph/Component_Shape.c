/*
=INSERT_TEMPLATE_HERE=

$Id: Component_Shape.c,v 1.3 2009/02/11 15:12:55 istakenv Exp $

X3D Shape Component

*/

#include <config.h>
#include <system.h>
#include <display.h>
#include <internal.h>

#include <libFreeWRL.h>

#include "../vrml_parser/Structs.h" /* point_XYZ */
#include "../main/headers.h"


float global_transparency = 1.0;
 
#define SET_SHADER_SELECTED_FALSE(x3dNode) \
	switch (X3D_NODE(x3dNode)->_nodeType) { \
		case NODE_ComposedShader: \
			X3D_COMPOSEDSHADER(x3dNode)->isSelected = FALSE; \
			break; \
		case NODE_ProgramShader: \
			X3D_PROGRAMSHADER(x3dNode)->isSelected = FALSE; \
			break; \
		case NODE_PackagedShader: \
			X3D_PROGRAMSHADER(x3dNode)->isSelected = FALSE; \
			break; \
		default: { \
			/* this is NOT a shader; should we say something, or just \
			   ignore? Lets ignore, for now */ \
		} \
	}

#define SET_FOUND_GOOD_SHADER(x3dNode) \
	switch (X3D_NODE(x3dNode)->_nodeType) { \
		case NODE_ComposedShader: \
			foundGoodShader = X3D_COMPOSEDSHADER(x3dNode)->isValid; \
			X3D_COMPOSEDSHADER(x3dNode)->isSelected = foundGoodShader; \
			break; \
		case NODE_ProgramShader: \
			foundGoodShader = X3D_PROGRAMSHADER(x3dNode)->isValid; \
			X3D_PROGRAMSHADER(x3dNode)->isSelected = foundGoodShader; \
			break; \
		case NODE_PackagedShader: \
			foundGoodShader = X3D_PROGRAMSHADER(x3dNode)->isValid; \
			X3D_PACKAGEDSHADER(x3dNode)->isSelected = foundGoodShader; \
			break; \
		default: { \
			/* this is NOT a shader; should we say something, or just \
			   ignore? Lets ignore, for now */ \
		} \
	}

void render_LineProperties (struct X3D_LineProperties *node) {
	GLint	factor;
	GLushort pat;

	if (node->applied) {
		global_lineProperties=TRUE;
		if (node->linewidthScaleFactor > 1.0) {
			glLineWidth(node->linewidthScaleFactor);
			glPointSize(node->linewidthScaleFactor);
		}
			
		if (node->linetype > 0) {
			factor = 1;
			pat = 0xffff; /* can not support fancy line types - this is the default */
			switch (node->linetype) {
				case 2: pat = 0xaaaa; break;
				case 3: pat = 0x4444; break;
				case 4: pat = 0xa4a4; break;
				case 5: pat = 0xaa44; break;
				case 6: pat = 0x0100; break;
				case 7: pat = 0x0100; break;
				case 10: pat = 0xaaaa; break;
				case 11: pat = 0x0170; break;
				case 12: pat = 0x0000; break;
				case 13: pat = 0x0000; break;
				default: {}
			}
			glLineStipple (factor,pat);
			glEnable(GL_LINE_STIPPLE);
		}
	}
}

void render_FillProperties (struct X3D_FillProperties *node) {
static GLubyte posSlope[] = {
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33};

static GLubyte negSlope[] = {
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99};

	static GLubyte vertLine[] = {
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66};

	static GLubyte crossHatch[] = {
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

	static GLubyte horizLine[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

	static GLubyte halftone[] = {
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
	0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55};
	static GLubyte *hatchStyle[] = {
		NULL,		/* 0 */
		horizLine,		/* 1 */
		vertLine,		/* 2 */
		posSlope,		/* 3 */
		negSlope,		/* 4 */
		crossHatch,		/* 5 */
		halftone,		/* 6 */
		halftone,		/* 7 */
		halftone,		/* 8 */
		halftone,		/* 9 */
		halftone,		/* 10 */
		halftone,		/* 11 */
		halftone,		/* 12 */
		halftone,		/* 13 */
		halftone,		/* 14 */
		halftone,		/* 15 */
		halftone,		/* 16 */
		halftone,		/* 17 */
		halftone,		/* 18 */
		halftone,		/* 19 */
	};

	global_fillProperties=TRUE;

	if (!node->filled) {
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	}
	if (node->hatched) {
		glColor3f (node->hatchColor.c[0], node->hatchColor.c[1],node->hatchColor.c[2]);
		if ((node->hatchStyle<1) || (node->hatchStyle>19)) {
			ConsoleMessage ("FillProperties, have a hatch style out of range");
			node->hatchStyle=1;
		}
		glPolygonStipple(hatchStyle[node->hatchStyle]);			
		glEnable (GL_POLYGON_STIPPLE);
	}
}


#define DO_MAT(diffusec,emissc,shinc,ambc,specc,transc) \
		\
	/* set the diffuseColor; we will reset this later if the		\
	   texture depth is 3 (RGB texture) */		\
		\
	for (i=0; i<3;i++){ dcol[i] = node->diffusec.c[i]; }		\
		\
	/* set the transparency here for the material */		\
	trans = 1.0 - node->transc;		\
		\
	if (trans<0.0) trans = 0.0;		\
	if (trans>=0.999999) trans = 0.9999999;		\
	global_transparency = trans;		\
		\
	dcol[3] = trans;		\
	scol[3] = trans;		\
	ecol[3] = trans;		\
		\
	/* the diffuseColor might change, depending on the texture depth - that we do not have yet */		\
	do_glMaterialfv(whichFace, GL_DIFFUSE, dcol);		\
		\
	/* do the ambientIntensity; this will allow lights with ambientIntensity to		\
	   illuminate it as per the spec. Note that lights have the ambientIntensity		\
	   set to 0.0 by default; this should make ambientIntensity lighting be zero		\
	   via OpenGL lighting equations. */		\
	amb = node->ambc;		\
		\
 		for(i=0; i<3; i++) { dcol[i] *= amb; } 		\
	do_glMaterialfv(whichFace, GL_AMBIENT, dcol);		\
		\
	for (i=0; i<3;i++){ scol[i] = node->specc.c[i]; }		\
	do_glMaterialfv(whichFace, GL_SPECULAR, scol);		\
		\
	for (i=0; i<3;i++){ ecol[i] = node->emissc.c[i]; }		\
	do_glMaterialfv(whichFace, GL_EMISSION, ecol);		\
		\
	shin = 128.0* node->shinc;		\
	do_shininess(whichFace,shin);





void render_TwoSidedMaterial (struct X3D_TwoSidedMaterial *node) {
	int i;
	float dcol[4];
	float ecol[4];
	float scol[4];
	float shin;
	float amb;
	float trans= 1.0;

	GLenum whichFace;

	/* first, do back */
	if (node->separateBackColor) {
		whichFace = GL_BACK;
		DO_MAT(backDiffuseColor,backEmissiveColor,backShininess,backAmbientIntensity,backSpecularColor,backTransparency)
		whichFace = GL_FRONT;
	} else {
		whichFace=GL_FRONT_AND_BACK;
	}
	DO_MAT(diffuseColor,emissiveColor,shininess,ambientIntensity,specularColor,transparency)
	
	/* remember this one */
	global_transparency = trans;
}

void render_Material (struct X3D_Material *node) {
	int i;
	float dcol[4];
	float ecol[4];
	float scol[4];
	float shin;
	float amb;
	float trans=1.0;

	#define whichFace GL_FRONT_AND_BACK

	DO_MAT(diffuseColor,emissiveColor,shininess,ambientIntensity,specularColor,transparency)
	
	/* remember this one */
	global_transparency = trans;
}


void child_Shape (struct X3D_Shape *node) {
	void *tmpN;

	if(!(node->geometry)) { return; }

	RECORD_DISTANCE

	if((render_collision) || (render_sensitive)) {
		/* only need to forward the call to the child */
		POSSIBLE_PROTO_EXPANSION(node->geometry,tmpN)
		render_node(tmpN);
		return;
	}

	/* reset textureTransform pointer */
	this_textureTransform = 0;
	global_lineProperties=FALSE;
	global_fillProperties=FALSE;
	global_transparency = 0.0;


	/* JAS - if not collision, and render_geom is not set, no need to go further */
	/* printf ("render_Shape vp %d geom %d light %d sens %d blend %d prox %d col %d\n",*/
	/* render_vp,render_geom,render_light,render_sensitive,render_blend,render_proximity,render_collision);*/

	/* a texture and a transparency flag... */
	texture_count = 0; /* will be >=1 if textures found */
	have_texture = FALSE;

	/* assume that lighting is enabled. Absence of Material or Appearance
	   node will turn lighting off; in this case, at the end of Shape, we
	   have to turn lighting back on again. */
	LIGHTING_ON

	/* if we have a very few samples, it means that:
		- Occlusion culling is working on this system (default is -1)
		- this node is very small in the scene;
		- if it is 0, it means that we are trying this shape for 
		  Occlusion Culling.
	*/

	if (!OccFailed && (node->__Samples <=4)) {
		/* draw this as a subdued grey */
       			glColor3f(0.3,0.3,0.3);

		/* dont do any textures, or anything */
		last_texture_type = NOTEXTURE;
	} else {
		/* is there an associated appearance node? */
		RENDER_MATERIAL_SUBNODES(node->appearance)
	}

	/* now, are we rendering blended nodes or normal nodes?*/
	if (render_blend == (node->_renderFlags & VF_Blend)) {

		#ifdef SHAPEOCCLUSION
		BEGINOCCLUSIONQUERY
		#endif

		POSSIBLE_PROTO_EXPANSION(node->geometry,tmpN)


		render_node(tmpN);

		#ifdef SHAPEOCCLUSION
		ENDOCCLUSIONQUERY
		#endif

	}

       /* did the lack of an Appearance or Material node turn lighting off? */
	LIGHTING_ON

	/* any line properties to reset? */
	if (global_fillProperties) {
		glDisable (GL_POLYGON_STIPPLE);
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	}
	if (global_lineProperties) {
		glDisable (GL_LINE_STIPPLE);
		glLineWidth(1.0);
		glPointSize(1.0);
	}

	/* any shader turned on? if so, turn it off */
	extern GLuint globalCurrentShader;
	TURN_APPEARANCE_SHADER_OFF
}


void child_Appearance (struct X3D_Appearance *node) {
	last_texture_type = NOTEXTURE;
	void *tmpN;
	struct X3D_Node *localShaderNode = NULL;

	/* printf ("in Appearance, this %d, nodeType %d\n",node, node->_nodeType);
	 printf (" vp %d geom %d light %d sens %d blend %d prox %d col %d\n",
	 render_vp,render_geom,render_light,render_sensitive,render_blend,render_proximity,render_collision); */

	/* shaders here/supported?? */
	if (node->shaders.n !=0) {
		int count;
		int foundGoodShader = FALSE;

		for (count=0; count<node->shaders.n; count++) {
			POSSIBLE_PROTO_EXPANSION(node->shaders.p[count], tmpN)

			/* have we found a valid shader yet? */
			if (foundGoodShader) {
				/* printf ("skipping shader %d of %d\n",count, node->shaders.n); */
				/* yes, just tell other shaders that they are not selected */
				SET_SHADER_SELECTED_FALSE(tmpN)
			} else {
				/* render this node; if it is valid, then we call this one the selected one */
				localShaderNode = tmpN;
				SET_FOUND_GOOD_SHADER(localShaderNode)
			}
		}
	}

	/* do NOT do material, if a shader has been found */
	if (localShaderNode == NULL) 
		RENDER_MATERIAL_SUBNODES(node->material)
	else {
             glColor3f(1,1,1); 
	}

	if (node->fillProperties) {
		POSSIBLE_PROTO_EXPANSION(node->fillProperties,tmpN)
		render_node(tmpN);
	}

	/* set line widths - if we have line a lineProperties node */
	if (node->lineProperties) {
		POSSIBLE_PROTO_EXPANSION(node->lineProperties,tmpN)
		render_node(tmpN);
	}

	if(node->texture) {
		/* we have to do a glPush, then restore, later */
		have_texture=TRUE;
		/* glPushAttrib(GL_ENABLE_BIT); */

		/* is there a TextureTransform? if no texture, fugutaboutit */
		POSSIBLE_PROTO_EXPANSION(node->textureTransform,this_textureTransform)
		/* this_textureTransform = node->textureTransform; */

		/* now, render the texture */
		POSSIBLE_PROTO_EXPANSION(node->texture,tmpN)
		render_node(tmpN);
	}
	/* shaders here/supported?? */
	if (localShaderNode != NULL) {
		/* printf ("running shader (%s) %d of %d\n",stringNodeType(X3D_NODE(localShaderNode)->_nodeType),count, node->shaders.n); */
		render_node(localShaderNode);
	}
}
