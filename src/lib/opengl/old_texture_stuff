// from textureThread (OSX old code)

#ifdef AQUA

    /* To get this thread to be able to manipulate textures, first, get the 
       Display attributes */
    if (!RUNNINGASPLUGIN) {
	CGDirectDisplayID display = CGMainDisplayID ();
	attribs[1] = CGDisplayIDToOpenGLDisplayMask (display);
	
	/* now, for this thread, create and join OpenGL Contexts */
	CGLChoosePixelFormat (attribs, &pixelFormat, &numPixelFormats);
	CGLCreateContext(pixelFormat, myglobalContext, &aqtextureContext);
	
	/* set the context for this thread so that we can share textures with
	   the main context (myglobalContext) */
	
	CGLSetCurrentContext(aqtextureContext);
	/* printf ("textureThread, have to try to remember to destroy this context\n"); */
    }
    
#else /* AQUA */

# ifdef DO_MULTI_OPENGL_THREADS
    textureContext = glXCreateContext(Xdpy, Xvi, GLcx, GL_FALSE);
    glXMakeCurrent(Xdpy,Xwin,textureContext);
# endif /* DO_MULTI_OPENGL_THREADS */

#endif /* AQUA */

    /* set up some common storage info */
#ifdef DO_MULTI_OPENGL_THREADS
    if (!RUNNINGASPLUGIN) {
	FW_GL_ENABLE(GL_TEXTURE_2D);
	glPixelStorei(GL_PACK_ALIGNMENT,1);
	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
    }
#endif



/************************************************************************/



from new_bind_image

#if 0 // OLD CODE


	if (textureInProcess > 0) {
		sched_yield();
		/* we are already working on a texture. Is it THIS one? */
		if (textureInProcess != thisTexture) {

			DEBUG_TEX("bind_image, textureInProcess = %d, texture_num %d returning \n",
				  textureInProcess,thisTexture);
			return;
		}
		DEBUG_TEX("bind_image, textureInProcess == texture_num\n");
	}


	/* signal that his is the one we want to work on */
	textureInProcess = thisTexture;


	/* is this one an unsquished movie texture? */
	if (myTableIndex->status == TEX_UNSQUASHED) { return; }


#ifdef AQUA
        if (RUNNINGASPLUGIN) {
	    DO_POSSIBLE_TEXTURE_SEQUENCE;
        }
#endif

#ifndef DO_MULTI_OPENGL_THREADS
        /* is this one read in, but requiring final manipulation
         * by THIS thread? */
	DO_POSSIBLE_TEXTURE_SEQUENCE;
#endif

	/* are we loading this one? */
	if (myTableIndex->status == TEX_LOADING) {
		return;
	}

	/* so, we really need to do this one... */

	/* is the thread currently doing something? */
	if (TextureParsing) return;

        TLOCK;
	if (currentlyWorkingOn <0) {
#ifdef TEXVERBOSE
	    printf ("currentlyWorkingOn WAS %d ",currentlyWorkingOn);
#endif
	    currentlyWorkingOn = thisTexture;
	    loadThisTexture = myTableIndex;
/* #ifdef TEXVERBOSE */
/* 	    printf ("just set currentlyWorkingOn to %d\n",currentlyWorkingOn); */
/* #endif */
	    DEBUG_TEX("just set currentlyWorkingOn to %d\n", currentlyWorkingOn);
	}
	T_LOCK_SIGNAL;
	TUNLOCK;
#endif // OLD CODE


from textureThread

/****************************************************************/
/*								*/
/*	Texture loading thread and associated functions		*/
/*								*/
/*	only do 1 texture at a time				*/
/*								*/
/*								*/
/*								*/
/****************************************************************/

#if 0 //MBFILES

	/* pattern matching, for finding internally handled types */
	char firstPNG[] = {0x89,0x50,0x4e,0x47};
	char firstJPG[] = {0xff,0xd8,0xff,0xe0};
#ifndef AQUA
	char firstMPGa[] = {0x00, 0x00, 0x01, 0xba};
	char firstMPGb[] = {0x00, 0x00, 0x01, 0xb3};
#endif

	filename = NULL;


#ifdef TEXVERBOSE 
	printf ("textureThread:start of findTextureFile for cwo %d type %d \n",
		cwo,loadThisTexture->nodeType);
#endif
	/* try to find this file. */

	if (loadThisTexture->nodeType !=NODE_PixelTexture) {

		/* lets make up the path and save it, and make it the global path */

		if (loadThisTexture->nodeType == NODE_ImageTexture) {
			thisParent = ((struct X3D_ImageTexture *)loadThisTexture->scenegraphNode)->__parenturl;
			thisUrl = ((struct X3D_ImageTexture *)loadThisTexture->scenegraphNode)->url;
		} else if (loadThisTexture->nodeType == NODE_MovieTexture) {
			thisParent = ((struct X3D_MovieTexture *)loadThisTexture->scenegraphNode)->__parenturl;
			thisUrl = ((struct X3D_MovieTexture *)loadThisTexture->scenegraphNode)->url;
		} else if (loadThisTexture->nodeType == NODE_VRML1_Texture2) {
			thisParent = ((struct X3D_VRML1_Texture2 *)loadThisTexture->scenegraphNode)->__parenturl;
			thisUrl = ((struct X3D_VRML1_Texture2 *)loadThisTexture->scenegraphNode)->filename;
		}
		mypath = STRDUP(thisParent->strptr);

		/* Dangerous, better alloc this string in function getValidFileFromUrl ... */
		filename = (char *)MALLOC(4096);

		if (getValidFileFromUrl (filename,mypath, &thisUrl, firstBytes)) {
#ifdef TEXVERBOSE 
		    printf ("textureThread: we were successful at locating %s\n",filename); 
#endif
		} else {
			ConsoleMessage ("Could not locate URL for texture %d (last choice was %s)\n",cwo,filename);
			/* So, we could not find the correct file. Make this into a blank PixelTexture, so that
			   at least this looks ok on the screen */
#ifdef TEXVERBOSE
			printf("textureThread: could not locate file from url: %s\n", filename);
#endif
			FREE_IF_NZ(filename);
			loadThisTexture->nodeType = NODE_PixelTexture;
			invalidFilePixelDataNode.n = 4;
			invalidFilePixelDataNode.p = invalidFilePixelData;
			loadThisTexture->pixelData = &invalidFilePixelDataNode;
		}
	}

	/* pixelTextures - lets just make a specific string for this one */
	if (loadThisTexture->nodeType == NODE_PixelTexture) {
		FREE_IF_NZ(filename);
		filename = (char *)MALLOC(4096);
		sprintf (filename,"PixelTexture_%d",(int)loadThisTexture);
	}

#ifdef AQUA
	/* on AQUA/OSX, let QuickTime do the conversion for us, but maybe we can help it out
	   by keeping a tab on what kind of image this is  */
	if ((loadThisTexture->nodeType == NODE_ImageTexture) || (loadThisTexture->nodeType == NODE_VRML1_Texture2)){
		loadThisTexture->imageType = INT_ID_UNDEFINED;
		if (strncmp(firstBytes,firstPNG,4) == 0) loadThisTexture->imageType = PNGTexture;
		if (strncmp(firstBytes,firstJPG,4) == 0) loadThisTexture->imageType = JPGTexture;
	}

#else /* AQUA */
	if ((loadThisTexture->nodeType == NODE_ImageTexture) || (loadThisTexture->nodeType == NODE_VRML1_Texture2)){
		loadThisTexture->imageType = INT_ID_UNDEFINED;
		if (strncmp(firstBytes,firstPNG,4) == 0) loadThisTexture->imageType = PNGTexture;
		if (strncmp(firstBytes,firstJPG,4) == 0) loadThisTexture->imageType = JPGTexture;

		/* is this a texture type that is *not* handled internally? */
		if ((strncmp(firstBytes,firstPNG,4) != 0) &&
		    (strncmp(firstBytes,firstJPG,4) != 0) &&
		    (strncmp(firstBytes,firstMPGa,4) != 0) &&
		    (strncmp(firstBytes,firstMPGb,4) != 0)) {

#ifdef TEXVERBOSE 
		    printf ("textureThread: trying to convert on %s\n", filename);
#endif
		    if (!filename) {
				printf("textureThread: error: trying to load null file\n");
				return FALSE;
		    }
/* #ifdef WIN32 */
/* 			if( IMAGECONVERT == NULL ) */
/* 			{ */
/* 				return FALSE; */
/* 			} */
/* #endif */
			sysline = (char *)MALLOC(sizeof(char)*(strlen(filename)+100));
			sprintf(sysline,"%s %s /tmp/freewrl%d.png", IMAGECONVERT, filename, getpid());
#ifdef TEXVERBOSE 
			printf ("textureThread: running convert on %s\n",sysline);
#endif

		    if (freewrlSystem (sysline) != TRUE) {
			printf ("Freewrl: error running convert line %s\n",sysline);
		    } else {
			FREE_IF_NZ(filename);
			filename = (char *)MALLOC(4096);
			sprintf (filename,"/tmp/freewrl%d.png",getpid());
		    }
		    FREE_IF_NZ (sysline);
		}
	}
#endif /* AQUA */

	/* save filename in data structure for later comparisons */
#ifdef TEXVERBOSE
	printf ("textureThread: new name, save it %d, name %s\n",cwo,filename);
#endif

	FREE_IF_NZ(loadThisTexture->filename);
	if (filename != NULL) {
	    loadThisTexture->filename = STRDUP(filename);
	    /* printf ("textureThread, so we have CACHE filename as %s\n",
	       loadThisTexture->filename); */
	} else {
	    ConsoleMessage ("error getting Texturefile\n");
	    return FALSE;
	}
	
	FREE_IF_NZ (filename);

#endif //MBFILES

	return TRUE;
}

#if 0 // OLD CODE
	if (findTextureFile(currentlyWorkingOn)) {
	    DEBUG_TEX("textureThread, findTextureFile ok for %d\n", currentlyWorkingOn);
	    /* is this a pixeltexture? */
	    if (loadThisTexture->nodeType==NODE_ImageTexture) {
		__reallyloadImageTexture();
	    } else if (loadThisTexture->nodeType==NODE_MovieTexture) {
		__reallyloadMovieTexture();
	    } else if (loadThisTexture->nodeType==NODE_VRML1_Texture2) {
		__reallyloadImageTexture();
	    } else {
		__reallyloadPixelTexure();
	    }  
	    DEBUG_TEX("textureThread, after reallyLoad for %d\n", (int) currentlyWorkingOn);

#ifdef DO_MULTI_OPENGL_THREADS
	    if (!RUNNINGASPLUGIN) {
		    DEBUG_TEX("tex %u needs binding, name %s\n",
			      loadThisTexture->OpenGLTexture,
			      loadThisTexture->filename);
		    do_possible_textureSequence(loadThisTexture);
		    DEBUG_TEX("tex %u now loaded\n", loadThisTexture->OpenGLTexture);
	    } else {
		    loadThisTexture->status = TEX_NEEDSBINDING;
	    }
#else /* DO_MULTI_OPENGL_THREADS */
	    /* we can not do this in 2 threads, let the main OpenGL thread do this */
	    /* printf ("we can not do multi-threads, %d set to TEX_NEEDSBINDING\n",
	       loadThisTexture->scenegraphNode); */
	    loadThisTexture->status = TEX_NEEDSBINDING;
#endif /* DO_MULTI_OPENGL_THREADS */

	} else {
	    ERROR_MSG("Could not find texture file: %s\n");
	}

	/* signal that we are finished */

	DEBUG_TEX("textureThread: finished parsing texture for currentlyWorkingOn %d\n", currentlyWorkingOn);
	TextureParsing=FALSE;
	currentlyWorkingOn = -1;
	REGENUNLOCK;
	TUNLOCK;

#endif // OLD CODE 



/********************************************************************************/
/* load specific types of textures						*/
/********************************************************************************/

/* load a PixelTexture that is stored as a MFInt32 */
static void __reallyloadPixelTexure() {
	/* PixelTexture variables */
	int hei,wid,depth;
	unsigned char *texture;
	int count;
	int ok;
	struct Multi_Int32 * myData;
	int *iptr;
	int tctr;

	myData = loadThisTexture->pixelData;
	iptr = (int *) myData->p;

	ok = TRUE;

	/* are there enough numbers for the texture? */
	if (myData->n < 3) {
		printf ("PixelTexture, need at least 3 elements, have %d\n",myData->n);
		ok = FALSE;
	} else {
		wid = *iptr; iptr++;
		hei = *iptr; iptr++;
		depth = *iptr; iptr++;

		if ((depth < 0) || (depth >4)) {
			printf ("PixelTexture, depth %d out of range, assuming 1\n",(int) depth);
			depth = 1;
		}
	
		if ((wid*hei-3) > myData->n) {
			printf ("PixelTexture, not enough data for wid %d hei %d, have %d\n",
					wid, hei, (wid*hei)-2);
			ok = FALSE;
		}
	}
		

	if (ok) {
		texture = (unsigned char *)MALLOC (wid*hei*4);
		tctr = 0;
		for (count = 0; count < (wid*hei); count++) {
			switch (depth) {
				case 1: {
					   texture[tctr++] = *iptr & 0xff;
					   break;
				   }
				case 2: {
					   texture[tctr++] = *iptr & 0x00ff;
					   texture[tctr++] = (*iptr>>8) & 0xff;
					   break;
				   }
				case 3: {
					   texture[tctr++] = (*iptr>>16) & 0xff; /*R*/
					   texture[tctr++] = (*iptr>>8) & 0xff;	 /*G*/
					   texture[tctr++] = (*iptr>>0) & 0xff; /*B*/
					   break;
				   }
				case 4: {
					   texture[tctr++] = (*iptr>>24) & 0xff; /*R*/
					   texture[tctr++] = (*iptr>>16) & 0xff; /*G*/
					   texture[tctr++] = (*iptr>>8) & 0xff;	 /*B*/
					   texture[tctr++] = (*iptr>>0) & 0xff; /*A*/
					   /* printf ("verify, %x %x %x %x\n",texture[tctr-4],texture[tctr-3],
						texture[tctr-2],texture[tctr-1]); */
					   break;
				   }
			}

			iptr++;
		}
		store_tex_info(loadThisTexture, (int)depth,(int)wid,(int)hei,texture,
			((depth==2)||(depth==4)) );
	}

}


#ifdef AQUA


/* render from aCGImageRef into a buffer, to get EXACT bits, as a CGImageRef contains only
estimates. */
/* from http://developer.apple.com/qa/qa2007/qa1509.html */

static inline double radians (double degrees) {return degrees * M_PI/180;}
CGContextRef CreateARGBBitmapContext (CGImageRef inImage) {
	CGContextRef    context = NULL;
	CGColorSpaceRef colorSpace;
	void *          bitmapData;
	int             bitmapByteCount;
	int             bitmapBytesPerRow;
	CGBitmapInfo	bitmapInfo;
	size_t		bitsPerComponent;

	 // Get image width, height. Well use the entire image.
	size_t pixelsWide = CGImageGetWidth(inImage);
	size_t pixelsHigh = CGImageGetHeight(inImage);

	// Declare the number of bytes per row. Each pixel in the bitmap in this
	// example is represented by 4 bytes; 8 bits each of red, green, blue, and
	// alpha.
	bitmapBytesPerRow   = (pixelsWide * 4);
	bitmapByteCount     = (bitmapBytesPerRow * pixelsHigh);

	// Use the generic RGB color space.
	colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
	if (colorSpace == NULL)
	{
	    fprintf(stderr, "Error allocating color space\n");
	    return NULL;
	}

	
	/* figure out the bitmap mapping */
	bitsPerComponent = CGImageGetBitsPerComponent(inImage);

	if (bitsPerComponent >= 8) {
		CGRect rect = {{0,0},{pixelsWide, pixelsHigh}};
		bitmapInfo = kCGImageAlphaNoneSkipLast;

		/* Allocate memory for image data. This is the destination in memory
		   where any drawing to the bitmap context will be rendered. */
		bitmapData = malloc( bitmapByteCount );
		if (bitmapData == NULL) {
		    fprintf (stderr, "Memory not allocated!");
		    CGColorSpaceRelease( colorSpace );
		    return NULL;
		}
	
		/* Create the bitmap context. We want pre-multiplied ARGB, 8-bits
		  per component. Regardless of what the source image format is
		  (CMYK, Grayscale, and so on) it will be converted over to the format
		  specified here by CGBitmapContextCreate. */
		context = CGBitmapContextCreate (bitmapData, pixelsWide, pixelsHigh,
			bitsPerComponent, bitmapBytesPerRow, colorSpace, bitmapInfo); 
	
		if (context == NULL) {
		    free (bitmapData);
		    fprintf (stderr, "Context not created!");
		} else {
	
			/* try scaling and rotating this image to fit our ideas on life in general */
			CGContextTranslateCTM (context, 0, pixelsHigh);
			CGContextScaleCTM (context,1.0, -1.0);
		}
		CGContextDrawImage(context, rect,inImage);
	} else {
		/* CGRect rect = {{0,0},{pixelsWide, pixelsHigh}}; */
		/* this is a mask. */

		printf ("bits per component of %d not handled\n",(int)bitsPerComponent);
		return NULL;
	}

	/* Make sure and release colorspace before returning */
	CGColorSpaceRelease( colorSpace );

	return context;
}


static void __reallyloadImageTexture() {
	CGImageRef 	image;
	CFStringRef	path;
	CFURLRef 	url;
	size_t 		image_width;
	size_t 		image_height;


	CGContextRef 	cgctx;

	/* Quicktime params */
	OSErr 		err;
	GraphicsImportComponent gi;
	Handle 		dataRef;
	OSType 		dataRefType;
	/* end of Quicktime params */

	unsigned char *	data;
	int		hasAlpha;

	CGDataProviderRef provider;
	CGImageSourceRef 	sourceRef;

	/* initialization */
	image = NULL;
	hasAlpha = FALSE;

	/* printf ("loading %s imageType %d\n",getShadowFileNamePtr(loadThisTexture->filename), loadThisTexture->imageType);  */

	path = CFStringCreateWithCString(NULL, getShadowFileNamePtr(loadThisTexture->filename), kCFStringEncodingUTF8);
	url = CFURLCreateWithFileSystemPath (NULL, path, kCFURLPOSIXPathStyle, 0);

	/* ok, we can define USE_CG_DATA_PROVIDERS or TRY_QUICKTIME...*/
	/* can we directly import this a a jpeg or png?? */
	if (loadThisTexture->imageType != INT_ID_UNDEFINED) {
		/* printf ("this is a JPEG texture, try direct loading\n"); */
		provider = CGDataProviderCreateWithURL(url);
		if (loadThisTexture->imageType == JPGTexture)  {
			image = CGImageCreateWithJPEGDataProvider(provider, NULL, FALSE, kCGRenderingIntentDefault);
		} else {
			image = CGImageCreateWithPNGDataProvider(provider, NULL, FALSE, kCGRenderingIntentDefault);
		}
		CGDataProviderRelease(provider);

	} else {

   		/* I dont know whether to use quicktime or not... Probably not... as the other ways using core 
			graphics seems to be ok. Anyway, I left this code in here, as maybe it might be of use for mpegs
		*/
		if (useQuicktime) {

			/* lets let quicktime decide on what to do with this image */
			err = QTNewDataReferenceFromCFURL(url,0, &dataRef, &dataRefType);

			if (dataRef != NULL) {
				err = GetGraphicsImporterForDataRef (dataRef, dataRefType, &gi);
				err = GraphicsImportCreateCGImage (gi, &image, 0);
				DisposeHandle (dataRef);
				CloseComponent(gi);
			}
		} else {
			sourceRef = CGImageSourceCreateWithURL(url,NULL);

			if (sourceRef != NULL) {
				image = CGImageSourceCreateImageAtIndex(sourceRef, 0, NULL);
				CFRelease (sourceRef);
			}
		}
	}

	CFRelease(url);
	CFRelease(path);

	image_width = CGImageGetWidth(image);
	image_height = CGImageGetHeight(image);
	hasAlpha = CGImageGetAlphaInfo(image) != kCGImageAlphaNone;

	#ifdef TEXVERBOSE
	if (hasAlpha) printf ("Image has Alpha channel\n"); else printf ("image - no alpha channel \n");

	printf ("raw image, AlphaInfo %x\n",(int) CGImageGetAlphaInfo(image));
	printf ("raw image, BitmapInfo %x\n",(int) CGImageGetBitmapInfo(image));
	printf ("raw image, BitsPerComponent %d\n",(int) CGImageGetBitsPerComponent(image));
	printf ("raw image, BitsPerPixel %d\n",(int) CGImageGetBitsPerPixel(image));
	printf ("raw image, BytesPerRow %d\n",(int) CGImageGetBytesPerRow(image));
	printf ("raw image, ImageHeight %d\n",(int) CGImageGetHeight(image));
	printf ("raw image, ImageWidth %d\n",(int) CGImageGetWidth(image));
	#endif
	
	/* now, lets "draw" this so that we get the exact bit values */
	cgctx = CreateARGBBitmapContext(image);

	 
	#ifdef TEXVERBOSE
	printf ("GetAlphaInfo %x\n",(int) CGBitmapContextGetAlphaInfo(cgctx));
	printf ("GetBitmapInfo %x\n",(int) CGBitmapContextGetBitmapInfo(cgctx));
	printf ("GetBitsPerComponent %d\n",(int) CGBitmapContextGetBitsPerComponent(cgctx));
	printf ("GetBitsPerPixel %d\n",(int) CGBitmapContextGetBitsPerPixel(cgctx));
	printf ("GetBytesPerRow %d\n",(int) CGBitmapContextGetBytesPerRow(cgctx));
	printf ("GetHeight %d\n",(int) CGBitmapContextGetHeight(cgctx));
	printf ("GetWidth %d\n",(int) CGBitmapContextGetWidth(cgctx));
	#endif
	
	data = (unsigned char *)CGBitmapContextGetData(cgctx);

	#ifdef TEXVERBOSE
	if (CGBitmapContextGetWidth(cgctx) < 65) {
		int i;

		printf ("dumping image\n");
		for (i=0; i<CGBitmapContextGetBytesPerRow(cgctx)*CGBitmapContextGetHeight(cgctx); i++) {
			printf ("%2x ",data[i]);
		}
		printf ("\n");
	}
	#endif

	/* is there possibly an error here, like a file that is not a texture? */
	if (CGImageGetBitsPerPixel(image) == 0) {
		ConsoleMessage ("texture file invalid: %s",loadThisTexture->filename);
	}

	if (data != NULL) {
		store_tex_info (loadThisTexture, 4, image_width, image_height,  data, hasAlpha);
	}

	CGContextRelease(cgctx);
}

#else

# if HAVE_JPEGLIB_H

/*********************************************************************************************/

/*
 * JPEG ERROR HANDLING: code from
 * http://courses.cs.deu.edu.tr/cse566/newpage2.htm
 *
 * The JPEG library's standard error handler (jerror.c) is divided into
 * several "methods" which you can override individually.  This lets you
 * adjust the behavior without duplicating a lot of code, which you might
 * have to update with each future release.
 *
 * Our example here shows how to override the "error_exit" method so that
 * control is returned to the library's caller when a fatal error occurs,
 * rather than calling exit() as the standard error_exit method does.
 *
 * We use C's setjmp/longjmp facility to return control.  This means that the
 * routine which calls the JPEG library must first execute a setjmp() call to
 * establish the return point.  We want the replacement error_exit to do a
 * longjmp().  But we need to make the setjmp buffer accessible to the
 * error_exit routine.  To do this, we make a private extension of the
 * standard JPEG error handler object.  (If we were using C++, we'd say we
 * were making a subclass of the regular error handler.)
 *
 * Here's the extended error handler struct:
 */

struct my_error_mgr {
	struct jpeg_error_mgr pub;    /* "public" fields */
	jmp_buf setjmp_buffer; /* for return to caller */
};

typedef struct my_error_mgr * my_error_ptr;

/*
 * Here's the routine that will replace the standard error_exit method:
 */

METHODDEF(void)
my_error_exit (j_common_ptr cinfo)
{
	/* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
  	my_error_ptr myerr = (my_error_ptr) cinfo->err;

 	/* Always display the message. */
  	/* We could postpone this until after returning, if we chose. */
  	/* JAS (*cinfo->err->output_message) (cinfo); */

 	/* Return control to the setjmp point */
  	longjmp(myerr->setjmp_buffer, 1);
}

/*********************************************************************************************/

static void __reallyloadImageTexture() {
	FILE *infile;
	char *filename;
	GLuint texture_num;
	unsigned char *image_data = 0;

	/* png reading variables */
	int rc;
	unsigned long image_width = 0;
	unsigned long image_height = 0;
	unsigned long image_rowbytes = 0;
	int image_channels = 0;
	double display_exponent = 0.0;

	/* jpeg variables */
	struct jpeg_decompress_struct cinfo;
	struct my_error_mgr jerr;
	JDIMENSION nrows;
	JSAMPROW row = 0;
	JSAMPROW rowptr[1];
	unsigned rowcount, columncount;
	int dp;

	int tempInt;


	filename = loadThisTexture->filename;
#if defined(_MSC_VER)
	infile = openLocalFile(filename,"rb");
#else
	infile = openLocalFile(filename,"r");
#endif


	/* printf ("reallyLoad on linux, texture type %d\n",loadThisTexture->imageType); */

	/* ok - this is a JPGTexture if specified, or a PNG texture either directly,
	   or converted. */

	if (loadThisTexture->imageType == JPGTexture) {



		/* it is not a png file - assume a jpeg file */
		/* start from the beginning again */
		rewind (infile);

		/* Select recommended processing options for quick-and-dirty output. */
		cinfo.two_pass_quantize = FALSE;
		cinfo.dither_mode = JDITHER_ORDERED;
		cinfo.desired_number_of_colors = 216;
		cinfo.dct_method = JDCT_FASTEST;
		cinfo.do_fancy_upsampling = FALSE;

		/* call my error handler if there is an error */
		cinfo.err = jpeg_std_error(&jerr.pub);
		jerr.pub.error_exit = my_error_exit;
		if (setjmp(jerr.setjmp_buffer)) {
			/* if we are here, we have a JPEG error */
			printf ("FreeWRL Image problem - could not read %s\n", filename);
			jpeg_destroy_compress((j_compress_ptr)&cinfo);
			fclose (infile);
			releaseTexture(loadThisTexture->scenegraphNode); 
			return;
		}


		jpeg_create_decompress(&cinfo);

		/* Specify data source for decompression */
		jpeg_stdio_src(&cinfo, infile);

		/* Read file header, set default decompression parameters */
		/* (void) jpeg_read_header(&cinfo, TRUE); */
		tempInt = jpeg_read_header(&cinfo, TRUE);


		/* Start decompressor */
		(void) jpeg_start_decompress(&cinfo);



		row = (JSAMPLE*)MALLOC(cinfo.output_width * sizeof(JSAMPLE)*cinfo.output_components);
		rowptr[0] = row;
		image_data = (unsigned char *)MALLOC(cinfo.output_width * sizeof (JSAMPLE) * cinfo.output_height * cinfo.output_components);
		/* Process data */
		for (rowcount = 0; rowcount < cinfo.output_height; rowcount++) {
			nrows = jpeg_read_scanlines(&cinfo, rowptr, 1);
			/* yield for a bit */
			sched_yield();


			for (columncount = 0; columncount < cinfo.output_width; columncount++) {
				for(dp=0; dp<cinfo.output_components; dp++) {
					image_data[(cinfo.output_height-rowcount-1)
							*cinfo.output_width*cinfo.output_components
					       		+ columncount* cinfo.output_components	+dp]
						= row[columncount*cinfo.output_components + dp];
				}
			}
		}


		if (jpeg_finish_decompress(&cinfo) != TRUE) {
			printf("warning: jpeg_finish_decompress error\n");
			releaseTexture(loadThisTexture->scenegraphNode);
		}
		jpeg_destroy_decompress(&cinfo);
		FREE_IF_NZ(row);

		store_tex_info(loadThisTexture,
			cinfo.output_components, 
			(int)cinfo.output_width,
			(int)cinfo.output_height,image_data,cinfo.output_components==4);
	} else {
		/* assume a PNG, whether direct, or converted from (eg) gif */
		rc = readpng_init(infile, &image_width, &image_height);
		if (rc != 0) {
		releaseTexture(loadThisTexture->scenegraphNode);
		switch (rc) {
			case 1:
				printf("[%s] is not a PNG file: incorrect signature\n", filename);
				break;
			case 2:
				printf("[%s] has bad IHDR (libpng longjmp)\n", filename);
				break;
			case 4:
				printf("insufficient memory\n");
				break;
			default:
				printf("unknown readpng_init() error\n");
				break;
			}
		} else {
			image_data = readpng_get_image(display_exponent, &image_channels,
					&image_rowbytes);

			store_tex_info (loadThisTexture, 
				image_channels, 
				(int)image_width, (int)image_height,
				image_data,image_channels==4);
		}
		readpng_cleanup (FALSE);
	}
	fclose (infile);
}

#endif /* HAVE_JPEGLIB_H */

#endif

